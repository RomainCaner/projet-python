================================================================================
    DOCUMENTATION TECHNIQUE - APPLICATION CONTRÃ”LE D'ACCÃˆS RESTAURANT
================================================================================

Date: 11 dÃ©cembre 2025
Projet: Mini-projet Python DSN - Institut Limayrac
Langage: Python 3.11
Framework: Tkinter + OpenCV

================================================================================
                            ARCHITECTURE GÃ‰NÃ‰RALE
================================================================================

L'application suit une architecture MVC (ModÃ¨le-Vue-ContrÃ´leur) avec Tkinter :

================================================================================
                        CLASSES ET LEURS RESPONSABILITÃ‰S
================================================================================

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ CLASSE                    â”‚ FICHIER                 â”‚ RÃ”LE                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Application               â”‚ app.py                  â”‚ FenÃªtre principale     â”‚
â”‚                           â”‚                         â”‚ Orchestration globale  â”‚
â”‚                           â”‚                         â”‚ Navigation entre vues  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Student                   â”‚ models/student.py       â”‚ ModÃ¨le de donnÃ©es      â”‚
â”‚                           â”‚                         â”‚ ReprÃ©sente un Ã©tudiant â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ AuthService               â”‚ services/auth.py        â”‚ Authentification admin â”‚
â”‚                           â”‚                         â”‚ VÃ©rification mot passe â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ CameraService             â”‚ services/camera.py      â”‚ Gestion camÃ©ra OpenCV  â”‚
â”‚                           â”‚                         â”‚ Capture ponctuelle     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ FaceStore                 â”‚ services/face_store.py  â”‚ Reconnaissance faciale â”‚
â”‚                           â”‚                         â”‚ DÃ©tection (Haar)       â”‚
â”‚                           â”‚                         â”‚ Encodage visages       â”‚
â”‚                           â”‚                         â”‚ Comparaison distances  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ StorageService            â”‚ services/storage.py     â”‚ Persistance JSON       â”‚
â”‚                           â”‚                         â”‚ CRUD Ã©tudiants         â”‚
â”‚                           â”‚                         â”‚ Gestion soldes         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ StudentService            â”‚ services/student_       â”‚ Logique mÃ©tier         â”‚
â”‚                           â”‚ service.py              â”‚ Enregistrement         â”‚
â”‚                           â”‚                         â”‚ Reconnaissance         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ LoginView                 â”‚ ui/login_view.py        â”‚ Ã‰cran de connexion     â”‚
â”‚                           â”‚                         â”‚ Formulaire auth        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ MainMenu                  â”‚ ui/main_menu.py         â”‚ Menu principal         â”‚
â”‚                           â”‚                         â”‚ Navigation modes       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ AddStudentView            â”‚ ui/add_student_view.py  â”‚ Ajout d'Ã©tudiant       â”‚
â”‚                           â”‚                         â”‚ Formulaire + capture   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ AccessControlView         â”‚ ui/access_control_      â”‚ ContrÃ´le d'accÃ¨s       â”‚
â”‚                           â”‚ view.py                 â”‚ Flux vidÃ©o continu     â”‚
â”‚                           â”‚                         â”‚ Reconnaissance temps   â”‚
â”‚                           â”‚                         â”‚ rÃ©el + dÃ©bit solde     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
DÃ‰TAILS PAR CLASSE
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”“
â”ƒ Application (app.py)                                                      â”ƒ
â”—â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”›

Type : Classe principale Tkinter (hÃ©rite de tk.Tk)

ResponsabilitÃ©s :
-----------------
â€¢ CrÃ©er la fenÃªtre principale (1200x800)
â€¢ Instancier tous les services (pattern Dependency Injection)
â€¢ GÃ©rer la navigation entre les diffÃ©rentes vues
â€¢ Maintenir l'Ã©tat global de l'application

MÃ©thodes principales :
----------------------
__init__()              â†’ Initialisation app + services
_set_view(widget)       â†’ Remplace vue courante (+ appel teardown)
show_login()            â†’ Affiche Ã©cran connexion
show_dashboard()        â†’ Affiche menu principal
show_add_student()      â†’ Affiche formulaire ajout
show_access_control()   â†’ Affiche contrÃ´le d'accÃ¨s

Attributs :
-----------
auth_service           : AuthService
camera_service         : CameraService
face_store             : FaceStore
student_service        : StudentService
current_view           : Widget Tkinter actuel

Exemple d'utilisation :
-----------------------
if __name__ == "__main__":
    app = Application()
    app.mainloop()  # Lance la boucle Ã©vÃ©nementielle Tkinter


â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”“
â”ƒ Student (models/student.py)                                               â”ƒ
â”—â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”›

Type : Dataclass Python (modÃ¨le de donnÃ©es)

ResponsabilitÃ©s :
-----------------
â€¢ ReprÃ©senter un Ã©tudiant avec toutes ses informations
â€¢ Fournir une structure de donnÃ©es cohÃ©rente
â€¢ Faciliter la sÃ©rialisation JSON

Attributs :
-----------
student_id      : str              # ID unique (ex: "12345")
first_name      : str              # PrÃ©nom
last_name       : str              # Nom
balance         : float            # Solde en â‚¬ (ex: 5.0)
image_path      : str              # Chemin photo
face_encoding   : List[float]      # Vecteur 10,000 floats

PropriÃ©tÃ©s calculÃ©es :
----------------------
display_name    : str              # "{first_name} {last_name}"

MÃ©thodes auto-gÃ©nÃ©rÃ©es (dataclass) :
------------------------------------
__init__()       â†’ Constructeur
__repr__()       â†’ ReprÃ©sentation string
__eq__()         â†’ Comparaison d'Ã©galitÃ©
__dict__         â†’ Conversion en dictionnaire (pour JSON)

Exemple d'utilisation :
-----------------------
student = Student(
    student_id="12345",
    first_name="Jean",
    last_name="Dupont",
    balance=5.0,
    image_path="data/images/12345.jpg",
    face_encoding=[0.1, 0.2, ..., 0.9]
)
print(student.display_name)  # "Jean Dupont"


â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”“
â”ƒ AuthService (services/auth.py)                                            â”ƒ
â”—â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”›

Type : Service mÃ©tier (authentification)

ResponsabilitÃ©s :
-----------------
â€¢ Charger les comptes administrateurs depuis data/admins.json
â€¢ VÃ©rifier les identifiants lors de la connexion
â€¢ GÃ©rer la liste des admins autorisÃ©s

MÃ©thodes principales :
----------------------
__init__(settings_file)     â†’ Charge admins.json
verify(username, password)  â†’ VÃ©rifie identifiants (retourne bool)
add_admin(username, pass)   â†’ Ajoute un nouvel admin (optionnel)

Attributs :
-----------
settings_file : Path         # Chemin vers admins.json
_admins       : List[dict]   # Liste des admins chargÃ©s

Format attendu admins.json :
----------------------------
{
  "admins": [
    {"username": "admin", "password": "admin123"}
  ]
}

Exemple d'utilisation :
-----------------------
auth = AuthService(Path("data/admins.json"))
if auth.verify("admin", "admin123"):
    print("Connexion rÃ©ussie")
else:
    print("Identifiants incorrects")


â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”“
â”ƒ CameraService (services/camera.py)                                        â”ƒ
â”—â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”›

Type : Service technique (gestion camÃ©ra)

ResponsabilitÃ©s :
-----------------
â€¢ Capturer des frames depuis la camÃ©ra via OpenCV
â€¢ GÃ©rer l'ouverture/fermeture de la camÃ©ra pour captures ponctuelles
â€¢ Fournir fallback en cas d'erreur camÃ©ra

MÃ©thodes principales :
----------------------
capture_frame(camera_index=0, delay_ms=0)  â†’ Capture 1 frame
save_frame(frame, destination)              â†’ Sauvegarde frame en JPG
_read_fallback()                            â†’ Lit image de secours (optionnel)

Attributs :
-----------
fallback_image : Optional[Path]   # Image de secours si camÃ©ra HS

Fonctionnement :
----------------
1. Ouvre cv2.VideoCapture(camera_index)
2. Lit une frame avec cap.read()
3. Ferme la camÃ©ra avec cap.release()
4. Retourne la frame (numpy array BGR)

Exemple d'utilisation :
-----------------------
camera = CameraService()
frame = camera.capture_frame()  # numpy array shape (H, W, 3)
camera.save_frame(frame, Path("photo.jpg"))


â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”“
â”ƒ FaceStore (services/face_store.py)                                        â”ƒ
â”—â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”›

Type : Service mÃ©tier (reconnaissance faciale)

ResponsabilitÃ©s :
-----------------
â€¢ DÃ©tecter les visages sur une image (Haar Cascade)
â€¢ Encoder un visage en vecteur numÃ©rique (100x100 normalisÃ©)
â€¢ Calculer la distance entre deux encodages
â€¢ Comparer un encodage avec une liste d'encodages connus

MÃ©thodes principales :
----------------------
encode_image(image_path)                â†’ Encode 1er visage trouvÃ©
encode_faces_from_frame(frame, boxes)   â†’ Encode tous visages dÃ©tectÃ©s
compute_distance(enc1, enc2)            â†’ Distance euclidienne
compare(known_encodings, target, tol)   â†’ Comparaison multiple
_detect_faces(image_gray)               â†’ DÃ©tection Haar Cascade
_encode_face_region(gray, x, y, w, h)   â†’ Encodage rÃ©gion

Attributs :
-----------
images_dir : Path                    # Dossier de stockage images
detector   : cv2.CascadeClassifier   # DÃ©tecteur Haar Cascade

Algorithme d'encodage :
-----------------------
1. Convertir image en niveau de gris
2. DÃ©tecter visages avec Haar Cascade â†’ rectangles (x, y, w, h)
3. Extraire rÃ©gion du visage (ROI)
4. Redimensionner Ã  100x100 pixels
5. Normaliser valeurs entre [0, 1]
6. Aplatir matrice â†’ vecteur 10,000 floats

Formule distance :
------------------
distance = âˆš(Î£(encoding1[i] - encoding2[i])Â²)

Exemple d'utilisation :
-----------------------
face_store = FaceStore(Path("data/images"))

# Encoder une photo
encoding = face_store.encode_image(Path("photo.jpg"))
# â†’ [0.123, 0.456, ..., 0.789]  (10,000 valeurs)

# Comparer deux visages
distance = face_store.compute_distance(encoding1, encoding2)
if distance < 15.0:
    print("MÃªme personne")


â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”“
â”ƒ StorageService (services/storage.py)                                    â”ƒ
â”—â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”›

Type : Service de persistance (couche d'accÃ¨s aux donnÃ©es)

ResponsabilitÃ©s :
-----------------
â€¢ Charger les Ã©tudiants depuis students.json
â€¢ Sauvegarder les Ã©tudiants dans students.json
â€¢ CrÃ©er/Mettre Ã  jour un Ã©tudiant (upsert)
â€¢ DÃ©crÃ©menter le solde d'un Ã©tudiant

MÃ©thodes principales :
----------------------
load_students()                        â†’ List[Student]
save_students(students)                â†’ Sauvegarde en JSON
upsert_student(student)                â†’ Ajoute/Met Ã  jour
decrement_balance(student_id, amount)  â†’ DÃ©bite solde

Attributs :
-----------
students_file : Path    # Chemin vers students.json

Format students.json :
----------------------
[
  {
    "student_id": "12345",
    "first_name": "Jean",
    "last_name": "Dupont",
    "balance": 5.0,
    "image_path": "data/images/12345.jpg",
    "face_encoding": [0.1, 0.2, ..., 0.9]
  }
]

Exemple d'utilisation :
-----------------------
storage = StorageService(Path("data/students.json"))

# Charger tous les Ã©tudiants
students = storage.load_students()

# Ajouter/modifier un Ã©tudiant
storage.upsert_student(new_student)

# DÃ©biter solde
updated = storage.decrement_balance("12345", 1.0)
print(updated.balance)  # Nouveau solde


â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”“
â”ƒ StudentService (services/student_service.py)                            â”ƒ
â”—â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”›

Type : Service mÃ©tier (orchestration logique Ã©tudiants)

ResponsabilitÃ©s :
-----------------
â€¢ Orchestrer l'enregistrement d'un nouvel Ã©tudiant
â€¢ Effectuer la reconnaissance faciale (match encoding)
â€¢ DÃ©crÃ©menter le solde lors d'un passage
â€¢ RÃ©cupÃ©rer la liste complÃ¨te des Ã©tudiants

MÃ©thodes principales :
----------------------
register_student(id, name, balance, image_path)  â†’ Student
match_encoding(encoding, tolerance)              â†’ Optional[Student]
decrement_balance(student_id, amount)            â†’ Optional[Student]
get_all_students()                               â†’ List[Student]

Attributs :
-----------
storage     : StorageService   # Service de persistance
face_store  : FaceStore        # Service reconnaissance faciale

Workflow register_student :
---------------------------
1. Encode le visage depuis image_path (FaceStore)
2. CrÃ©e l'objet Student avec l'encoding
3. Sauvegarde via StorageService
4. Retourne l'objet Student crÃ©Ã©

Workflow match_encoding :
-------------------------
1. Charge tous les Ã©tudiants (StorageService)
2. Pour chaque Ã©tudiant, calcule distance avec encoding fourni
3. Si distance < tolerance, retourne l'Ã©tudiant
4. Sinon retourne None

Exemple d'utilisation :
-----------------------
student_service = StudentService(storage, face_store)

# Enregistrer un Ã©tudiant
student = student_service.register_student(
    student_id="12345",
    first_name="Jean",
    last_name="Dupont",
    balance=5.0,
    image_path=Path("photo.jpg")
)

# ReconnaÃ®tre un visage
encoding = face_store.encode_image(Path("test.jpg"))
matched = student_service.match_encoding(encoding, tolerance=15.0)
if matched:
    print(f"Reconnu: {matched.display_name}")


â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”“
â”ƒ LoginView (ui/login_view.py)                                              â”ƒ
â”—â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”›

Type : Vue Tkinter (Ã©cran de connexion)

ResponsabilitÃ©s :
-----------------
â€¢ Afficher formulaire de connexion (username + password)
â€¢ Valider les identifiants via AuthService
â€¢ Appeler callback on_success si connexion rÃ©ussie
â€¢ Afficher message d'erreur si Ã©chec

MÃ©thodes principales :
----------------------
__init__(master, auth_service, on_success)  â†’ Construit interface
_handle_login()                             â†’ GÃ¨re clic bouton connexion

Attributs :
-----------
auth_service  : AuthService          # Service d'authentification
on_success    : Callable[[], None]   # Callback si connexion OK
username_var  : tk.StringVar         # Variable Tkinter username
password_var  : tk.StringVar         # Variable Tkinter password

Composants Tkinter :
--------------------
- Titre "Connexion administrateur"
- Label + Entry pour username
- Label + Entry pour password (mode masquÃ©)
- Bouton "Se connecter"

Exemple d'utilisation :
-----------------------
def on_login_success():
    print("Connexion rÃ©ussie")
    app.show_dashboard()

login_view = LoginView(
    root,
    auth_service=auth_service,
    on_success=on_login_success
)


â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”“
â”ƒ MainMenu (ui/main_menu.py)                                                â”ƒ
â”—â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”›

Type : Vue Tkinter (menu principal)

ResponsabilitÃ©s :
-----------------
â€¢ Afficher les options du menu principal
â€¢ Rediriger vers mode "Ajout Ã©tudiant"
â€¢ Rediriger vers mode "ContrÃ´le d'accÃ¨s"
â€¢ Permettre la dÃ©connexion

MÃ©thodes principales :
----------------------
__init__(master, on_add_student, on_access_control, on_logout)

Attributs (callbacks) :
-----------------------
on_add_student      : Callable[[], None]   # Vers ajout Ã©tudiant
on_access_control   : Callable[[], None]   # Vers contrÃ´le accÃ¨s
on_logout           : Callable[[], None]   # Vers connexion

Composants Tkinter :
--------------------
- Titre "ContrÃ´le d'accÃ¨s - Tableau de bord"
- Bouton "Ajouter un nouvel Ã©tudiant"
- Bouton "ContrÃ´le d'accÃ¨s"
- Bouton "Se dÃ©connecter"

Exemple d'utilisation :
-----------------------
menu = MainMenu(
    root,
    on_add_student=app.show_add_student,
    on_access_control=app.show_access_control,
    on_logout=app.show_login
)


â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”“
â”ƒ AddStudentView (ui/add_student_view.py)                                   â”ƒ
â”—â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”›

Type : Vue Tkinter (formulaire ajout Ã©tudiant)

ResponsabilitÃ©s :
-----------------
â€¢ Afficher formulaire de saisie (ID, nom, prÃ©nom, solde)
â€¢ Permettre capture photo via webcam (mode continu touche C)
â€¢ Permettre import photo depuis fichier
â€¢ Valider et enregistrer l'Ã©tudiant via StudentService
â€¢ Afficher messages de confirmation/erreur

MÃ©thodes principales :
----------------------
__init__(master, student_service, camera_service, on_back)
_start_preview()      â†’ Lance prÃ©visualisation continue (OpenCV)
_import_image()       â†’ Import depuis fichier
_submit()             â†’ Valide et enregistre Ã©tudiant
_reset_form()         â†’ RÃ©initialise le formulaire

Attributs :
-----------
student_service   : StudentService
camera_service    : CameraService
on_back           : Callable[[], None]
selected_image    : Optional[Path]       # Photo sÃ©lectionnÃ©e
student_id_var    : tk.StringVar
first_name_var    : tk.StringVar
last_name_var     : tk.StringVar
balance_var       : tk.StringVar
photo_status      : tk.StringVar

Composants Tkinter :
--------------------
- Titre "Ajout d'un Ã©tudiant"
- Entry : Identifiant
- Entry : PrÃ©nom
- Entry : Nom
- Entry : Solde initial (â‚¬)
- Label : Statut photo
- Bouton "Mode prÃ©visualisation continue (touche C)"
- Bouton "Choisir un fichier..."
- Bouton "Enregistrer"
- Bouton "Retour"

Workflow capture :
------------------
1. Utilisateur clique "Mode prÃ©visualisation"
2. FenÃªtre OpenCV s'ouvre avec flux continu
3. Utilisateur appuie sur C pour capturer
4. Image sauvegardÃ©e dans data/images/{id}.jpg
5. Statut mis Ã  jour "Photo capturÃ©e"

Exemple d'utilisation :
-----------------------
add_view = AddStudentView(
    root,
    student_service=student_service,
    camera_service=camera_service,
    on_back=app.show_dashboard
)


â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”“
â”ƒ AccessControlView (ui/access_control_view.py)                             â”ƒ
â”—â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”›

Type : Vue Tkinter (contrÃ´le d'accÃ¨s temps rÃ©el)

ResponsabilitÃ©s :
-----------------
â€¢ Ouvrir la camÃ©ra en mode continu (pas de fermeture entre frames)
â€¢ Afficher flux vidÃ©o en temps rÃ©el (20 FPS)
â€¢ DÃ©tecter et reconnaÃ®tre les visages automatiquement
â€¢ Dessiner overlays (rectangles verts/rouges + noms)
â€¢ DÃ©biter le solde automatiquement avec cooldown anti-doublon
â€¢ Afficher statut et dernier passage

MÃ©thodes principales :
----------------------
__init__(master, student_service, camera_service, face_store, on_back)
_update_preview_with_recognition()    â†’ Boucle principale (20 FPS)
_handle_back()                        â†’ Retour menu
teardown()                            â†’ Fermeture propre camÃ©ra

Attributs :
-----------
student_service       : StudentService
camera_service        : CameraService
face_store            : FaceStore
on_back               : Callable[[], None]
debit_amount          : float = 1.0           # Montant dÃ©bitÃ©
_cap                  : cv2.VideoCapture      # CamÃ©ra ouverte
_running              : bool                  # ContrÃ´le boucle
_last_detection_time  : float                 # Pour cooldown
_cooldown_seconds     : int = 3               # DÃ©lai anti-doublon
status_var            : tk.StringVar          # Statut reconnaissance
last_event_var        : tk.StringVar          # Dernier passage

Composants Tkinter :
--------------------
- En-tÃªte : Titre + Bouton "â† Retour au menu"
- Label : Flux vidÃ©o (800x600)
- Label : Statut (ex: "âœ“ AccÃ¨s autorisÃ© : Jean Dupont | Solde : 4.0 â‚¬")
- Label : Dernier passage (ex: "Dernier passage : Jean Dupont Ã  14:32:15")

Boucle principale (toutes les 50ms) :
--------------------------------------
1. Lire frame depuis camÃ©ra (_cap.read())
2. DÃ©tecter visages + encoder (face_store.encode_faces_from_frame)
3. Pour chaque visage :
   a) Comparer avec base Ã©tudiants (student_service.match_encoding)
   b) Si reconnu :
      - Rectangle VERT + nom
      - VÃ©rifier cooldown
      - Si OK : dÃ©biter solde + maj statut
   c) Si inconnu :
      - Rectangle ROUGE + "INCONNU"
      - Afficher "AccÃ¨s refusÃ©"
4. Convertir frame BGR â†’ RGB
5. Redimensionner 800x600
6. Afficher dans Tkinter (ImageTk.PhotoImage)
7. Rappeler aprÃ¨s 50ms (self.after)

Cooldown anti-doublon :
-----------------------
Ã‰vite de dÃ©biter plusieurs fois le mÃªme Ã©tudiant.
Si dernier dÃ©bit < 3 secondes, on reconnaÃ®t mais ne dÃ©bite pas.

Fermeture propre :
------------------
teardown() libÃ¨re la camÃ©ra (_cap.release()) et annule les callbacks.

Exemple d'utilisation :
-----------------------
control_view = AccessControlView(
    root,
    student_service=student_service,
    camera_service=camera_service,
    face_store=face_store,
    on_back=app.show_dashboard,
    debit_amount=1.0
)

================================================================================
                    INTERACTIONS ENTRE LES CLASSES
================================================================================

Application
    â”‚
    â”œâ”€â”€> AuthService          (vÃ©rification login)
    â”œâ”€â”€> CameraService        (injected dans vues)
    â”œâ”€â”€> FaceStore            (injected dans StudentService)
    â”œâ”€â”€> StorageService       (injected dans StudentService)
    â””â”€â”€> StudentService       (orchestration)
            â”‚
            â”œâ”€â”€> StorageService    (persistance)
            â””â”€â”€> FaceStore         (reconnaissance)

LoginView â”€â”€> AuthService.verify()
    â”‚
    â””â”€â”€> Application.show_dashboard()  (si succÃ¨s)

MainMenu
    â”œâ”€â”€> Application.show_add_student()
    â”œâ”€â”€> Application.show_access_control()
    â””â”€â”€> Application.show_login()  (dÃ©connexion)

AddStudentView
    â”œâ”€â”€> CameraService.capture_frame()
    â””â”€â”€> StudentService.register_student()
            â”‚
            â”œâ”€â”€> FaceStore.encode_image()
            â””â”€â”€> StorageService.upsert_student()

AccessControlView
    â”œâ”€â”€> cv2.VideoCapture(0)  (direct, camÃ©ra continue)
    â”œâ”€â”€> FaceStore.encode_faces_from_frame()
    â”œâ”€â”€> StudentService.match_encoding()
    â”‚       â”‚
    â”‚       â”œâ”€â”€> StorageService.load_students()
    â”‚       â””â”€â”€> FaceStore.compute_distance()
    â”‚
    â””â”€â”€> StudentService.decrement_balance()
            â”‚
            â””â”€â”€> StorageService.decrement_balance()

================================================================================

ğŸ“ Structure du projet
----------------------

projet-python/
â”œâ”€â”€ app.py                          # Point d'entrÃ©e principal
â”œâ”€â”€ models/                         # ModÃ¨les de donnÃ©es
â”‚   â””â”€â”€ student.py                  # Classe Student (dataclass)
â”œâ”€â”€ services/                       # Logique mÃ©tier
â”‚   â”œâ”€â”€ auth.py                     # Authentification admin
â”‚   â”œâ”€â”€ camera.py                   # Gestion camÃ©ra OpenCV
â”‚   â”œâ”€â”€ face_store.py               # Encodage/reconnaissance faciale
â”‚   â”œâ”€â”€ storage.py                  # Persistance JSON
â”‚   â””â”€â”€ student_service.py          # Service mÃ©tier Ã©tudiants
â”œâ”€â”€ ui/                             # Interfaces Tkinter
â”‚   â”œâ”€â”€ login_view.py               # Ã‰cran de connexion
â”‚   â”œâ”€â”€ main_menu.py                # Menu principal
â”‚   â”œâ”€â”€ add_student_view.py         # Ajout d'Ã©tudiant
â”‚   â””â”€â”€ access_control_view.py      # ContrÃ´le d'accÃ¨s vidÃ©o
â”œâ”€â”€ utils/                          # Utilitaires
â”‚   â””â”€â”€ paths.py                    # Constantes de chemins
â””â”€â”€ data/                           # DonnÃ©es persistÃ©es
    â”œâ”€â”€ admins.json                 # Comptes administrateurs
    â”œâ”€â”€ students.json               # Base d'Ã©tudiants
    â””â”€â”€ images/                     # Photos enregistrÃ©es

================================================================================
                        1. APP.PY - POINT D'ENTRÃ‰E
================================================================================

RÃ´le : Orchestrateur principal qui crÃ©e les services et gÃ¨re la navigation

Code clÃ© :
----------
class Application(tk.Tk):
    def __init__(self):
        # FenÃªtre principale Tkinter 1200x800
        self.geometry("1200x800")
        
        # Initialisation des services (pattern Dependency Injection)
        storage = StorageService(STUDENTS_FILE)           # Gestion JSON
        self.face_store = FaceStore(IMAGES_DIR)          # Reconnaissance faciale
        self.auth_service = AuthService(ADMINS_FILE)     # Authentification
        self.camera_service = CameraService()             # CamÃ©ra OpenCV
        self.student_service = StudentService(storage, self.face_store)
        
        # Navigation : dÃ©marre sur l'Ã©cran de connexion
        self.show_login()

MÃ©thodes de navigation :
------------------------
- show_login()           â†’ Affiche Ã©cran de connexion
- show_dashboard()       â†’ Affiche menu principal
- show_add_student()     â†’ Affiche formulaire ajout Ã©tudiant
- show_access_control()  â†’ Affiche contrÃ´le d'accÃ¨s vidÃ©o
- _set_view(widget)      â†’ Remplace la vue courante

================================================================================
                    2. SERVICES/AUTH.PY - AUTHENTIFICATION
================================================================================

RÃ´le : Gestion des comptes administrateurs

Fonctionnement :
----------------
1. Charge data/admins.json au dÃ©marrage
2. VÃ©rifie les identifiants lors de la connexion
3. Mots de passe en clair (simplifiÃ© pour le projet)

Code clÃ© :
----------
class AuthService:
    def verify(self, username: str, password: str) -> bool:
        # Compare username/password avec data/admins.json
        for admin in self._admins:
            if admin["username"] == username:
                return admin["password"] == password
        return False

Identifiants par dÃ©faut :
-------------------------
- Username: admin
- Password: admin123

Fichier data/admins.json :
--------------------------
{
  "admins": [
    {
      "username": "admin",
      "password": "admin123"
    }
  ]
}

================================================================================
                  3. SERVICES/CAMERA.PY - GESTION CAMÃ‰RA
================================================================================

RÃ´le : Capture d'images via OpenCV

Code clÃ© :
----------
class CameraService:
    def capture_frame(self, camera_index: int = 0):
        cap = cv2.VideoCapture(camera_index)  # Ouvre camÃ©ra
        success, frame = cap.read()            # Capture 1 frame
        cap.release()                          # Ferme camÃ©ra
        return frame

Utilisation :
-------------
- Mode "Ajout Ã©tudiant" : captures ponctuelles pour enregistrer photo
- Mode "ContrÃ´le d'accÃ¨s" : camÃ©ra ouverte en continu dans la vue

================================================================================
                  4. MODELS/STUDENT.PY - MODÃˆLE DE DONNÃ‰ES
================================================================================

RÃ´le : Structure de donnÃ©es pour un Ã©tudiant

Code clÃ© :
----------
@dataclass
class Student:
    student_id: str              # ID unique (ex: "12345")
    first_name: str              # PrÃ©nom
    last_name: str               # Nom
    balance: float               # Solde en â‚¬ (ex: 5.0)
    image_path: str              # Chemin photo (ex: "data/images/12345.jpg")
    face_encoding: List[float]   # Encodage facial (10,000 floats)
    
    @property
    def display_name(self) -> str:
        return f"{self.first_name} {self.last_name}"

Type : Python dataclass (gÃ©nÃ¨re automatiquement __init__, __repr__, etc.)

================================================================================
              5. SERVICES/FACE_STORE.PY - RECONNAISSANCE FACIALE
================================================================================

RÃ´le : DÃ©tection, encodage et comparaison de visages

Technologies utilisÃ©es :
------------------------
- OpenCV Haar Cascade pour la dÃ©tection
- Distance euclidienne pour la comparaison
- Encodage simplifiÃ© (100x100 pixels normalisÃ©s)

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
5.1 DÃ‰TECTION (Haar Cascade)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def _detect_faces(self, image_gray):
    # DÃ©tecteur de visages OpenCV (algorithme Haar Cascade)
    faces = self.detector.detectMultiScale(
        image_gray, 
        scaleFactor=1.1,   # Pyramide d'Ã©chelles (dÃ©tection multi-tailles)
        minNeighbors=5     # Seuil de confiance
    )
    return faces  # Liste de rectangles [(x, y, w, h), ...]

Comment Ã§a marche :
-------------------
- Haar Cascade analyse l'image avec des motifs prÃ©-entraÃ®nÃ©s
- DÃ©tecte les visages Ã  diffÃ©rentes Ã©chelles
- Retourne coordonnÃ©es des rectangles englobants (x, y, largeur, hauteur)

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
5.2 ENCODAGE
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def _encode_face_region(self, image_gray, x, y, w, h):
    roi = image_gray[y:y+h, x:x+w]           # Extraire rÃ©gion visage
    resized = cv2.resize(roi, (100, 100))    # Redimensionner 100x100
    norm = resized.astype("float32") / 255.0 # Normaliser [0,1]
    return norm.flatten().tolist()           # Aplatir en vecteur 10,000 floats

Principe :
----------
1. Extraire la rÃ©gion du visage dÃ©tectÃ©
2. Redimensionner Ã  100x100 pixels (standardisation)
3. Normaliser les valeurs entre 0 et 1
4. Aplatir la matrice 100x100 en vecteur 1D de 10,000 nombres

Exemple de vecteur :
-------------------
[0.123, 0.456, 0.789, ..., 0.321]  # 10,000 valeurs

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
5.3 COMPARAISON
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def compute_distance(encoding1, encoding2):
    vec1 = np.array(encoding1)
    vec2 = np.array(encoding2)
    return np.linalg.norm(vec1 - vec2)  # Distance euclidienne

Formule mathÃ©matique :
----------------------
distance = âˆš(Î£(v1[i] - v2[i])Â²)

InterprÃ©tation :
----------------
- Distance = 0   â†’ Visages identiques
- Distance < 15  â†’ Visages similaires (tolÃ©rance actuelle)
- Distance > 15  â†’ Visages diffÃ©rents

TolÃ©rance actuelle : 15.0
-------------------------
Plus la valeur est basse, plus la reconnaissance est stricte.
Avec 15.0, la reconnaissance est trÃ¨s permissive.

Valeurs recommandÃ©es :
- 0.4-0.6 : Stricte (peu de faux positifs, mais peut rater des vrais)
- 0.8-1.2 : ModÃ©rÃ©e (Ã©quilibre)
- 15+     : Permissive (beaucoup de faux positifs possibles)

================================================================================
                6. SERVICES/STORAGE.PY - PERSISTANCE JSON
================================================================================

RÃ´le : Sauvegarde et chargement des Ã©tudiants

Code clÃ© :
----------
class StorageService:
    def load_students(self) -> List[Student]:
        raw = json.loads(self.students_file.read_text(encoding="utf-8"))
        return [Student(**student) for student in raw]
    
    def save_students(self, students: List[Student]) -> None:
        payload = [student.__dict__ for student in students]
        self.students_file.write_text(
            json.dumps(payload, indent=2, ensure_ascii=False), 
            encoding="utf-8"
        )
    
    def upsert_student(self, student: Student):
        students = self.load_students()                    # Charge JSON
        students = [s for s in students 
                    if s.student_id != student.student_id] # Supprime doublon
        students.append(student)                           # Ajoute nouveau
        self.save_students(students)                       # Sauvegarde
    
    def decrement_balance(self, student_id: str, amount: float):
        students = self.load_students()
        for student in students:
            if student.student_id == student_id:
                student.balance = max(0.0, student.balance - amount)
                break
        self.save_students(students)

Format data/students.json :
---------------------------
[
  {
    "student_id": "12345",
    "first_name": "Jean",
    "last_name": "Dupont",
    "balance": 5.0,
    "image_path": "data/images/12345.jpg",
    "face_encoding": [0.123, 0.456, ...] // 10,000 valeurs
  }
]

================================================================================
          7. SERVICES/STUDENT_SERVICE.PY - LOGIQUE MÃ‰TIER
================================================================================

RÃ´le : Orchestre les opÃ©rations sur les Ã©tudiants

Code clÃ© :
----------
class StudentService:
    def register_student(self, student_id, first_name, last_name, 
                        balance, image_path):
        # 1. Encoder le visage depuis la photo
        encoding = self.face_store.encode_image(image_path)
        
        # 2. CrÃ©er l'objet Student
        student = Student(
            student_id=student_id,
            first_name=first_name,
            last_name=last_name,
            balance=balance,
            image_path=str(image_path),
            face_encoding=encoding
        )
        
        # 3. Sauvegarder en JSON
        self.storage.upsert_student(student)
        return student
    
    def match_encoding(self, encoding, tolerance=15):
        # Compare avec tous les Ã©tudiants enregistrÃ©s
        students = self.storage.load_students()
        for student in students:
            distance = self.face_store.compute_distance(
                encoding, 
                student.face_encoding
            )
            if distance < tolerance:
                return student
        return None

================================================================================
        8. UI/ACCESS_CONTROL_VIEW.PY - CONTRÃ”LE D'ACCÃˆS VIDÃ‰O
================================================================================

RÃ´le : Flux vidÃ©o en continu avec reconnaissance automatique

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
8.1 INITIALISATION
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def __init__(self, ...):
    # Ouvrir camÃ©ra UNE SEULE FOIS (flux continu)
    self._cap = cv2.VideoCapture(0)
    
    # Variables de contrÃ´le
    self._running = True
    self._last_detection_time = 0
    self._cooldown_seconds = 3  # Anti-doublon
    
    # Interface Tkinter
    self.preview_label = ttk.Label(...)  # Affichage vidÃ©o
    self.status_var = tk.StringVar(...)  # Statut reconnaissance
    
    # Lancer boucle de reconnaissance
    self._update_preview_with_recognition()

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
8.2 BOUCLE PRINCIPALE (20 FPS)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def _update_preview_with_recognition(self):
    # â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    # â”‚ Ã‰TAPE 1 : Lire frame depuis camÃ©ra ouverte â”‚
    # â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    ret, frame = self._cap.read()  # Lecture non-bloquante
    frame_display = frame.copy()
    current_time = time.time()
    
    # â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    # â”‚ Ã‰TAPE 2 : DÃ©tecter et encoder les visages  â”‚
    # â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    results = self.face_store.encode_faces_from_frame(frame, with_boxes=True)
    # results = [(encoding, (x, y, w, h)), ...]
    
    # â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    # â”‚ Ã‰TAPE 3 : Comparer avec base d'Ã©tudiants   â”‚
    # â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    for encoding, (x, y, w, h) in results:
        student = self.student_service.match_encoding(encoding, tolerance=15)
        
        if student:
            # â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
            # â”‚ VISAGE RECONNU âœ“                   â”‚
            # â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
            
            # Dessiner rectangle VERT + nom
            cv2.rectangle(frame_display, (x, y), (x+w, y+h), (0, 255, 0), 2)
            cv2.putText(
                frame_display, 
                student.display_name, 
                (x, y-10),
                cv2.FONT_HERSHEY_SIMPLEX, 
                0.6, 
                (0, 255, 0), 
                2
            )
            
            # DÃ©biter solde (avec cooldown 3s pour Ã©viter doublons)
            if current_time - self._last_detection_time > 3:
                self._last_detection_time = current_time
                
                updated = self.student_service.decrement_balance(
                    student.student_id, 
                    1.0  # Montant dÃ©bitÃ©
                )
                
                balance = updated.balance
                self.status_var.set(
                    f"âœ“ AccÃ¨s autorisÃ© : {student.display_name} | "
                    f"Solde : {balance:.2f} â‚¬"
                )
        else:
            # â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
            # â”‚ VISAGE INCONNU âœ—                   â”‚
            # â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
            
            # Rectangle ROUGE + "INCONNU"
            cv2.rectangle(frame_display, (x, y), (x+w, y+h), (0, 0, 255), 2)
            cv2.putText(
                frame_display, 
                "INCONNU", 
                (x, y-10),
                cv2.FONT_HERSHEY_SIMPLEX, 
                0.6, 
                (0, 0, 255), 
                2
            )
            self.status_var.set("âœ— Visage non reconnu - AccÃ¨s refusÃ©")
    
    # â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    # â”‚ Ã‰TAPE 4 : Afficher frame dans Tkinter      â”‚
    # â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    frame_rgb = cv2.cvtColor(frame_display, cv2.COLOR_BGR2RGB)
    frame_resized = cv2.resize(frame_rgb, (800, 600))
    img = Image.fromarray(frame_resized)
    photo = ImageTk.PhotoImage(image=img)
    self.preview_label.config(image=photo)
    self.preview_label.image = photo  # Garde rÃ©fÃ©rence
    
    # â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    # â”‚ Ã‰TAPE 5 : Rappeler dans 50ms (boucle)      â”‚
    # â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    if self._running:
        self._after_id = self.after(50, self._update_preview_with_recognition)
        # 50ms = 20 FPS

Cooldown (anti-doublon) :
-------------------------
Sans cooldown, un Ã©tudiant serait dÃ©bitÃ© 20 fois par seconde (20 FPS).
Avec cooldown de 3s, un seul dÃ©bit toutes les 3 secondes maximum.

Fermeture propre :
------------------
def teardown(self):
    self._running = False          # ArrÃªte la boucle
    if self._cap:
        self._cap.release()        # LibÃ¨re la camÃ©ra
    if self._after_id:
        self.after_cancel(...)     # Annule les callbacks Tkinter

================================================================================
                  9. UI/ADD_STUDENT_VIEW.PY - AJOUT Ã‰TUDIANT
================================================================================

RÃ´le : Formulaire d'enregistrement avec capture photo

FonctionnalitÃ©s :
-----------------
1. Formulaire Tkinter (ID, nom, prÃ©nom, solde)
2. Capture photo via webcam avec prÃ©visualisation continue
3. Import de fichier image alternatif
4. Validation et enregistrement

Code clÃ© - Capture continue :
-----------------------------
def _start_preview(self):
    # Ouvre fenÃªtre OpenCV avec flux continu
    cap = cv2.VideoCapture(0)
    
    while True:
        ret, frame = cap.read()
        cv2.imshow("PrÃ©visualisation - Appuyez sur C pour capturer", frame)
        
        key = cv2.waitKey(1) & 0xFF
        if key == ord('c'):      # Touche C = capturer
            self._save_capture(frame)
            break
        elif key == ord('q'):    # Touche Q = quitter
            break
    
    cap.release()
    cv2.destroyAllWindows()

Avantages :
-----------
- Utilisateur voit sa tÃªte en temps rÃ©el
- Choisit le meilleur moment pour capturer
- Pas de capture ratÃ©e

================================================================================
                      10. FLUX DE DONNÃ‰ES COMPLET
================================================================================

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
10.1 AJOUT D'UN Ã‰TUDIANT
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 1. SAISIE FORMULAIRE                                                     â”‚
â”‚    - ID: "12345"                                                         â”‚
â”‚    - Nom: "Dupont"                                                       â”‚
â”‚    - PrÃ©nom: "Jean"                                                      â”‚
â”‚    - Solde: 5.0 â‚¬                                                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                    â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 2. CAPTURE PHOTO                                                         â”‚
â”‚    - OpenCV capture frame                                                â”‚
â”‚    - Sauvegarde â†’ data/images/12345.jpg                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                    â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 3. ENCODAGE FACIAL (FaceStore)                                           â”‚
â”‚    a) DÃ©tection Haar Cascade â†’ rectangle (x, y, w, h)                   â”‚
â”‚    b) Extraction ROI (Region of Interest)                                â”‚
â”‚    c) Redimensionnement 100x100 pixels                                   â”‚
â”‚    d) Normalisation [0,1]                                                â”‚
â”‚    e) Aplatissement â†’ vecteur [10,000 floats]                           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                    â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 4. CRÃ‰ATION OBJET STUDENT                                                â”‚
â”‚    Student(                                                              â”‚
â”‚        student_id="12345",                                               â”‚
â”‚        first_name="Jean",                                                â”‚
â”‚        last_name="Dupont",                                               â”‚
â”‚        balance=5.0,                                                      â”‚
â”‚        image_path="data/images/12345.jpg",                               â”‚
â”‚        face_encoding=[0.123, 0.456, ..., 0.789]  # 10,000 valeurs       â”‚
â”‚    )                                                                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                    â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 5. SAUVEGARDE JSON (StorageService)                                      â”‚
â”‚    - Charge students.json existant                                       â”‚
â”‚    - Supprime doublon si ID existe dÃ©jÃ                                   â”‚
â”‚    - Ajoute nouvel Ã©tudiant                                              â”‚
â”‚    - Sauvegarde data/students.json                                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
10.2 CONTRÃ”LE D'ACCÃˆS (RECONNAISSANCE)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 1. INITIALISATION                                                        â”‚
â”‚    - Ouvrir camÃ©ra cv2.VideoCapture(0)                                   â”‚
â”‚    - Charger base Ã©tudiants depuis students.json                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                    â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 2. BOUCLE INFINIE (20 FPS)                                               â”‚
â”‚    while running:                                                        â”‚
â”‚        â†“                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 3. LECTURE FRAME                                                         â”‚
â”‚    ret, frame = cap.read()                                               â”‚
â”‚    â†’ Image BGR 640x480 (ou rÃ©solution camÃ©ra)                            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 4. DÃ‰TECTION VISAGES (Haar Cascade)                                      â”‚
â”‚    results = face_store.encode_faces_from_frame(frame)                   â”‚
â”‚    â†’ [(encoding1, (x1, y1, w1, h1)), (encoding2, ...), ...]             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 5. POUR CHAQUE VISAGE DÃ‰TECTÃ‰                                            â”‚
â”‚    for encoding, (x, y, w, h) in results:                               â”‚
â”‚        â†“                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
            â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 6. COMPARAISON AVEC BASE (StudentService)                                â”‚
â”‚    for student in all_students:                                          â”‚
â”‚        distance = compute_distance(encoding, student.face_encoding)      â”‚
â”‚        if distance < 15:  # TolÃ©rance                                    â”‚
â”‚            â†’ MATCH TROUVÃ‰                                                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
            â†“                                    â†“
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ RECONNU âœ“     â”‚              â”‚ INCONNU âœ—            â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
            â†“                                    â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 7a. VISAGE RECONNU           â”‚  â”‚ 7b. VISAGE INCONNU           â”‚
â”‚ - Rectangle VERT             â”‚  â”‚ - Rectangle ROUGE            â”‚
â”‚ - Afficher nom               â”‚  â”‚ - Afficher "INCONNU"         â”‚
â”‚ - VÃ©rifier cooldown (3s)     â”‚  â”‚ - Message "AccÃ¨s refusÃ©"     â”‚
â”‚ - DÃ©biter solde (-1.0â‚¬)      â”‚  â”‚                              â”‚
â”‚ - Afficher solde restant     â”‚  â”‚                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
            â†“                                    â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 8. AFFICHAGE FRAME                                                       â”‚
â”‚    - Convertir BGR â†’ RGB                                                 â”‚
â”‚    - Redimensionner 800x600                                              â”‚
â”‚    - Convertir â†’ ImageTk.PhotoImage                                      â”‚
â”‚    - Afficher dans Tkinter Label                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
            â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 9. ATTENDRE 50ms                                                         â”‚
â”‚    self.after(50, self._update_preview_with_recognition)                 â”‚
â”‚    â†’ Retour Ã  l'Ã©tape 3 (boucle infinie)                                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

================================================================================
                    11. PERFORMANCE ET LIMITATIONS
================================================================================

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
FORCES
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

âœ“ Flux vidÃ©o fluide (20 FPS)
âœ“ Reconnaissance en temps rÃ©el
âœ“ DÃ©bit automatique avec anti-doublon (cooldown 3s)
âœ“ Interface intuitive Tkinter
âœ“ Overlay visuel (rectangles + noms)
âœ“ Gestion du solde persistÃ©e
âœ“ Authentification admin
âœ“ Logs de passages (timestamp)
âœ“ Architecture modulaire (facile Ã  maintenir)
âœ“ Pas de dÃ©pendances lourdes (dlib/face_recognition)

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
LIMITATIONS
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

âœ— Encodage simple (100x100 pixels) moins prÃ©cis que dlib/face_recognition
âœ— Haar Cascade sensible Ã  l'Ã©clairage et l'angle
âœ— TolÃ©rance 15 trÃ¨s permissive (risque de faux positifs)
âœ— Pas de chiffrement des donnÃ©es (JSON en clair)
âœ— Mots de passe admin en clair
âœ— Pas de logs d'audit persistants
âœ— JSON non optimisÃ© pour grandes bases (>1000 Ã©tudiants)
âœ— Mono-utilisateur (pas de concurrence)

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
AMÃ‰LIORATIONS POSSIBLES
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ”¹ Base de donnÃ©es SQLite au lieu de JSON
   - RequÃªtes SQL optimisÃ©es
   - Transactions ACID
   - Index sur student_id

ğŸ”¹ Hash bcrypt pour mots de passe
   - Stockage sÃ©curisÃ©
   - Protection contre rainbow tables

ğŸ”¹ Logs d'accÃ¨s persistants (audit trail)
   - CSV ou table SQLite
   - Timestamp, Ã©tudiant, solde avant/aprÃ¨s, statut

ğŸ”¹ AmÃ©lioration reconnaissance
   - Utiliser face_recognition (dlib)
   - TolÃ©rance adaptative selon conditions
   - Multiple photos par Ã©tudiant

ğŸ”¹ Multi-camÃ©ras
   - GÃ©rer plusieurs points d'accÃ¨s
   - Configuration dynamique

ğŸ”¹ Interface d'administration web
   - Flask/Django
   - Gestion Ã©tudiants Ã  distance
   - Statistiques/rapports

ğŸ”¹ Export de donnÃ©es
   - CSV pour comptabilitÃ©
   - Rapports PDF

ğŸ”¹ Notifications
   - Email si solde bas
   - Alertes si accÃ¨s refusÃ©

================================================================================
                           12. CONFIGURATION
================================================================================

Fichiers de configuration :
---------------------------

1. utils/paths.py
   - STUDENTS_FILE: Path("data/students.json")
   - IMAGES_DIR: Path("data/images")
   - ADMINS_FILE: Path("data/admins.json")

2. ParamÃ¨tres modifiables :

   Dans ui/access_control_view.py :
   - debit_amount: float = 1.0        # Montant dÃ©bitÃ© par passage
   - _cooldown_seconds: int = 3       # Cooldown anti-doublon
   - tolerance: float = 15.0          # Seuil de reconnaissance
   - FPS: int = 20 (50ms)             # FrÃ©quence de rafraÃ®chissement

   Dans app.py :
   - geometry("1200x800")             # Taille fenÃªtre

   Dans services/face_store.py :
   - scaleFactor: float = 1.1         # Haar Cascade
   - minNeighbors: int = 5            # Haar Cascade
   - resize: tuple = (100, 100)       # Taille encodage

Identifiants par dÃ©faut :
-------------------------
Username: admin
Password: admin123

================================================================================
                          13. DÃ‰PANNAGE
================================================================================

ProblÃ¨me : CamÃ©ra ne s'ouvre pas
---------------------------------
Solution :
- VÃ©rifier qu'aucune autre application n'utilise la camÃ©ra
- Tester avec cv2.VideoCapture(0) dans un script simple
- Autoriser l'accÃ¨s camÃ©ra dans paramÃ¨tres Windows

ProblÃ¨me : Reconnaissance ne fonctionne pas
-------------------------------------------
Solution :
- VÃ©rifier l'Ã©clairage (Haar Cascade sensible)
- Augmenter la tolÃ©rance (15 â†’ 20)
- VÃ©rifier que face_encoding existe dans students.json
- Tester avec plusieurs photos du mÃªme visage

ProblÃ¨me : Application lente
-----------------------------
Solution :
- RÃ©duire FPS (50ms â†’ 100ms)
- RÃ©duire rÃ©solution vidÃ©o (800x600 â†’ 640x480)
- Optimiser taille encodage (100x100 â†’ 50x50)

ProblÃ¨me : DÃ©bit multiple du mÃªme Ã©tudiant
------------------------------------------
Solution :
- Augmenter cooldown (3s â†’ 5s)
- VÃ©rifier que _last_detection_time se met Ã  jour

================================================================================
                        14. TESTS ET VALIDATION
================================================================================

ScÃ©narios de test :
-------------------

1. Test ajout Ã©tudiant
   - CrÃ©er Ã©tudiant avec photo
   - VÃ©rifier sauvegarde dans students.json
   - VÃ©rifier photo dans data/images/

2. Test reconnaissance valide
   - Ã‰tudiant enregistrÃ© se prÃ©sente
   - VÃ©rifier rectangle vert + nom
   - VÃ©rifier dÃ©bit solde
   - VÃ©rifier message "AccÃ¨s autorisÃ©"

3. Test reconnaissance invalide
   - Personne non enregistrÃ©e se prÃ©sente
   - VÃ©rifier rectangle rouge + "INCONNU"
   - VÃ©rifier message "AccÃ¨s refusÃ©"
   - VÃ©rifier aucun dÃ©bit

4. Test solde insuffisant
   - CrÃ©er Ã©tudiant avec solde 0â‚¬
   - VÃ©rifier reconnaissance mais message "Solde insuffisant"

5. Test cooldown
   - MÃªme Ã©tudiant reste devant camÃ©ra
   - VÃ©rifier un seul dÃ©bit toutes les 3 secondes

6. Test authentification
   - Login avec mauvais identifiants â†’ refus
   - Login avec bons identifiants â†’ accÃ¨s menu

================================================================================
                  15. FONCTIONNEMENT DE LA BIBLIOTHÃˆQUE OPENCV
================================================================================

OpenCV (Open Computer Vision) est une bibliothÃ¨que open-source de vision par
ordinateur et d'apprentissage automatique.

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
15.1 QU'EST-CE QU'OPENCV ?
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

CrÃ©Ã©e par Intel en 1999, OpenCV contient plus de 2500 algorithmes optimisÃ©s
pour :
â€¢ DÃ©tection et reconnaissance d'objets/visages
â€¢ Tracking d'objets en mouvement
â€¢ Analyse de vidÃ©os
â€¢ Traitement d'images (filtres, transformations)
â€¢ Vision 3D et reconstruction
â€¢ Machine Learning

Langages supportÃ©s :
--------------------
â€¢ Python (notre cas)
â€¢ C++
â€¢ Java
â€¢ MATLAB

SystÃ¨mes d'exploitation :
-------------------------
â€¢ Windows
â€¢ Linux
â€¢ macOS
â€¢ Android
â€¢ iOS

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
15.2 CONCEPTS FONDAMENTAUX
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ A. REPRÃ‰SENTATION D'UNE IMAGE                                               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Une image en OpenCV est un tableau NumPy 3D :

Structure :
-----------
shape = (hauteur, largeur, canaux)

Exemple :
---------
image = cv2.imread("photo.jpg")
print(image.shape)  # (480, 640, 3)
# 480 pixels de haut
# 640 pixels de large
# 3 canaux de couleur (B, G, R)

AccÃ¨s aux pixels :
------------------
# Pixel en position (y=100, x=200)
pixel = image[100, 200]
# â†’ [125, 87, 200]  (B, G, R)

# Modifier un pixel (le rendre rouge)
image[100, 200] = [0, 0, 255]  # BGR


â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ B. FORMAT DE COULEURS BGR vs RGB                                            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

OpenCV utilise BGR (Blue-Green-Red) au lieu de RGB !

Pourquoi BGR ?
--------------
Raison historique : les premiÃ¨res camÃ©ras utilisaient ce format.

ConsÃ©quence :
-------------
Pour afficher avec Matplotlib ou Tkinter (qui utilisent RGB), il faut convertir.

Conversion BGR â†’ RGB :
----------------------
rgb_image = cv2.cvtColor(bgr_image, cv2.COLOR_BGR2RGB)

Conversion BGR â†’ Niveau de gris :
----------------------------------
gray_image = cv2.cvtColor(bgr_image, cv2.COLOR_BGR2GRAY)


â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ C. COORDONNÃ‰ES ET RECTANGLES                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

SystÃ¨me de coordonnÃ©es :
------------------------
(0,0) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€> X (largeur)
  â”‚
  â”‚
  â”‚
  â†“
  Y (hauteur)

Rectangle reprÃ©sentÃ© par :
--------------------------
(x, y, w, h)
â€¢ x : position horizontale du coin supÃ©rieur gauche
â€¢ y : position verticale du coin supÃ©rieur gauche
â€¢ w : largeur (width)
â€¢ h : hauteur (height)

Exemple :
---------
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                            â”‚
â”‚   (100, 50)                â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”             â”‚
â”‚   â”‚          â”‚ h=80        â”‚
â”‚   â”‚  visage  â”‚             â”‚
â”‚   â”‚          â”‚             â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜             â”‚
â”‚      w=120                 â”‚
â”‚                            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Rectangle : (100, 50, 120, 80)

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
15.3 FONCTIONS OPENCV UTILISÃ‰ES DANS LE PROJET
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 1. cv2.VideoCapture(index)                                                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

RÃ´le : Ouvre un flux vidÃ©o (webcam ou fichier)

ParamÃ¨tres :
------------
index : int ou str
  â€¢ 0 = premiÃ¨re webcam
  â€¢ 1 = deuxiÃ¨me webcam
  â€¢ "video.mp4" = fichier vidÃ©o
  â€¢ "rtsp://..." = flux rÃ©seau

Retour : Objet VideoCapture

Exemple :
---------
cap = cv2.VideoCapture(0)  # Ouvre webcam

if cap.isOpened():
    print("CamÃ©ra ouverte")
else:
    print("Erreur : camÃ©ra indisponible")

cap.release()  # Ferme la camÃ©ra

MÃ©thodes principales :
----------------------
cap.read()                    â†’ (bool, frame)  # Lit une frame
cap.release()                 â†’ None           # Ferme la camÃ©ra
cap.isOpened()                â†’ bool           # VÃ©rifie si ouvert
cap.get(cv2.CAP_PROP_FPS)     â†’ float          # FPS camÃ©ra
cap.set(cv2.CAP_PROP_WIDTH)   â†’ bool           # Change rÃ©solution


â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 2. cap.read()                                                                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

RÃ´le : Lit une frame depuis le flux vidÃ©o

Retour : (success, frame)
---------
â€¢ success : bool â†’ True si lecture OK
â€¢ frame : numpy.ndarray â†’ Image BGR

Exemple :
---------
cap = cv2.VideoCapture(0)

ret, frame = cap.read()
if ret:
    print(f"Frame capturÃ©e : {frame.shape}")
    # (480, 640, 3)
else:
    print("Ã‰chec de lecture")

Boucle infinie (flux continu) :
--------------------------------
while True:
    ret, frame = cap.read()
    if not ret:
        break
    
    # Traiter la frame
    cv2.imshow("Video", frame)
    
    if cv2.waitKey(1) & 0xFF == ord('q'):
        break

cap.release()


â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 3. cv2.cvtColor(image, conversion_code)                                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

RÃ´le : Convertit l'espace de couleurs d'une image

Codes de conversion courants :
-------------------------------
cv2.COLOR_BGR2RGB        â†’ BGR vers RGB
cv2.COLOR_BGR2GRAY       â†’ BGR vers niveau de gris
cv2.COLOR_RGB2BGR        â†’ RGB vers BGR
cv2.COLOR_BGR2HSV        â†’ BGR vers HSV (teinte, saturation, valeur)

Exemple :
---------
bgr_image = cv2.imread("photo.jpg")    # Charge en BGR
gray_image = cv2.cvtColor(bgr_image, cv2.COLOR_BGR2GRAY)
rgb_image = cv2.cvtColor(bgr_image, cv2.COLOR_BGR2RGB)

print(bgr_image.shape)   # (480, 640, 3)
print(gray_image.shape)  # (480, 640)    â† 1 seul canal
print(rgb_image.shape)   # (480, 640, 3)

Pourquoi convertir en niveau de gris ?
---------------------------------------
â€¢ RÃ©duit la complexitÃ© (1 canal au lieu de 3)
â€¢ AmÃ©liore performance des algorithmes
â€¢ NÃ©cessaire pour Haar Cascade


â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 4. cv2.CascadeClassifier(xml_path)                                           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

RÃ´le : Charge un dÃ©tecteur d'objets prÃ©-entraÃ®nÃ© (Haar Cascade)

Fichiers XML fournis avec OpenCV :
-----------------------------------
haarcascade_frontalface_default.xml  â†’ Visages de face
haarcascade_eye.xml                  â†’ Yeux
haarcascade_smile.xml                â†’ Sourires
haarcascade_fullbody.xml             â†’ Corps entier

Exemple :
---------
cascade_path = cv2.data.haarcascades + "haarcascade_frontalface_default.xml"
detector = cv2.CascadeClassifier(cascade_path)

MÃ©thode principale :
--------------------
detector.detectMultiScale(image, scaleFactor, minNeighbors)


â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 5. detector.detectMultiScale(image, scaleFactor, minNeighbors)              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

RÃ´le : DÃ©tecte des objets (visages) Ã  diffÃ©rentes Ã©chelles

ParamÃ¨tres :
------------
image         : Image en niveau de gris
scaleFactor   : float (ex: 1.1)
                â†’ Facteur de rÃ©duction entre chaque Ã©chelle
                â†’ Plus petit = plus prÃ©cis mais plus lent
minNeighbors  : int (ex: 5)
                â†’ Nombre minimum de voisins pour valider dÃ©tection
                â†’ Plus grand = moins de faux positifs

Retour : Liste de rectangles [(x, y, w, h), ...]
---------

Exemple :
---------
gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
faces = detector.detectMultiScale(gray, scaleFactor=1.1, minNeighbors=5)

print(faces)
# array([[100, 50, 120, 120],    â† Visage 1
#        [300, 80, 110, 110]])   â† Visage 2

for (x, y, w, h) in faces:
    print(f"Visage dÃ©tectÃ© Ã  ({x}, {y}) de taille {w}x{h}")

Comment Ã§a marche (Haar Cascade) :
-----------------------------------
1. Image parcourue Ã  diffÃ©rentes Ã©chelles (pyramide)
2. Ã€ chaque position, algorithme teste des motifs prÃ©-entraÃ®nÃ©s
3. Motifs = caractÃ©ristiques Haar (diffÃ©rences zones claires/sombres)
4. Si suffisamment de motifs matchent â†’ visage dÃ©tectÃ©


â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 6. cv2.rectangle(image, pt1, pt2, color, thickness)                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

RÃ´le : Dessine un rectangle sur une image

ParamÃ¨tres :
------------
image      : Image Ã  modifier (modifiÃ©e en place !)
pt1        : tuple (x1, y1) â†’ Coin supÃ©rieur gauche
pt2        : tuple (x2, y2) â†’ Coin infÃ©rieur droit
color      : tuple (B, G, R) â†’ Couleur BGR
thickness  : int â†’ Ã‰paisseur trait (ou -1 pour remplir)

Exemple :
---------
# Rectangle vert autour d'un visage
x, y, w, h = 100, 50, 120, 120
cv2.rectangle(image, (x, y), (x+w, y+h), (0, 255, 0), 2)
#                                         â†‘ vert BGR  â†‘ 2 pixels

# Rectangle rouge rempli
cv2.rectangle(image, (200, 100), (300, 200), (0, 0, 255), -1)

Couleurs courantes (BGR) :
--------------------------
Rouge    : (0, 0, 255)
Vert     : (0, 255, 0)
Bleu     : (255, 0, 0)
Jaune    : (0, 255, 255)
Magenta  : (255, 0, 255)
Cyan     : (255, 255, 0)
Blanc    : (255, 255, 255)
Noir     : (0, 0, 0)


â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 7. cv2.putText(image, text, org, font, scale, color, thickness)             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

RÃ´le : Ã‰crit du texte sur une image

ParamÃ¨tres :
------------
image      : Image Ã  modifier
text       : str â†’ Texte Ã  afficher
org        : tuple (x, y) â†’ Position coin infÃ©rieur gauche du texte
font       : cv2.FONT_* â†’ Police de caractÃ¨res
scale      : float â†’ Taille police (ex: 0.6)
color      : tuple (B, G, R) â†’ Couleur BGR
thickness  : int â†’ Ã‰paisseur trait

Polices disponibles :
---------------------
cv2.FONT_HERSHEY_SIMPLEX       â†’ Standard, lisible
cv2.FONT_HERSHEY_PLAIN         â†’ Petite
cv2.FONT_HERSHEY_COMPLEX       â†’ Complexe
cv2.FONT_HERSHEY_SCRIPT_SIMPLEX â†’ Script

Exemple :
---------
cv2.putText(
    image,
    "Jean Dupont",           # Texte
    (100, 50),               # Position
    cv2.FONT_HERSHEY_SIMPLEX,
    0.6,                     # Taille
    (0, 255, 0),             # Vert
    2                        # Ã‰paisseur
)

Astuce positionnement :
-----------------------
Pour texte au-dessus d'un rectangle :
x, y, w, h = visage_coords
cv2.putText(image, nom, (x, y-10), ...)  # y-10 pour Ãªtre au-dessus


â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 8. cv2.resize(image, dsize, interpolation)                                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

RÃ´le : Redimensionne une image

ParamÃ¨tres :
------------
image         : Image source
dsize         : tuple (width, height) â†’ Nouvelle taille
interpolation : MÃ©thode d'interpolation (optionnel)
                â€¢ cv2.INTER_LINEAR (dÃ©faut) â†’ BilinÃ©aire
                â€¢ cv2.INTER_AREA â†’ RÃ©trÃ©cissement
                â€¢ cv2.INTER_CUBIC â†’ Bicubique (qualitÃ©)

Exemple :
---------
image = cv2.imread("photo.jpg")  # (1080, 1920, 3)

# Redimensionner Ã  640x480
resized = cv2.resize(image, (640, 480))
print(resized.shape)  # (480, 640, 3)

# Attention : (width, height) mais shape donne (height, width, channels) !

# RÃ©duction pour miniature
thumbnail = cv2.resize(image, (100, 100), interpolation=cv2.INTER_AREA)


â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 9. cv2.imread(filepath) et cv2.imwrite(filepath, image)                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

RÃ´le : Lire et Ã©crire des images sur disque

cv2.imread(filepath, flags) :
-----------------------------
ParamÃ¨tres :
  filepath : str ou Path â†’ Chemin fichier
  flags : (optionnel)
    â€¢ cv2.IMREAD_COLOR (dÃ©faut) â†’ Charge en BGR
    â€¢ cv2.IMREAD_GRAYSCALE â†’ Charge en niveau de gris
    â€¢ cv2.IMREAD_UNCHANGED â†’ Inclut canal alpha

Retour : numpy.ndarray ou None si Ã©chec

Exemple :
---------
image = cv2.imread("photo.jpg")
if image is None:
    print("Erreur : fichier introuvable")
else:
    print(f"Image chargÃ©e : {image.shape}")

gray = cv2.imread("photo.jpg", cv2.IMREAD_GRAYSCALE)


cv2.imwrite(filepath, image) :
------------------------------
ParamÃ¨tres :
  filepath : str ou Path â†’ Chemin destination
  image : numpy.ndarray â†’ Image Ã  sauvegarder

Retour : bool â†’ True si succÃ¨s

Exemple :
---------
success = cv2.imwrite("output.jpg", image)
if success:
    print("Image sauvegardÃ©e")

# Format automatique selon extension
cv2.imwrite("image.png", image)  # PNG
cv2.imwrite("image.jpg", image)  # JPEG

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
15.4 HAAR CASCADE : COMMENT Ã‡A MARCHE ?
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Haar Cascade est un algorithme de dÃ©tection d'objets proposÃ© par Paul Viola
et Michael Jones en 2001.

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ PRINCIPE                                                                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

1. CaractÃ©ristiques de Haar (Haar-like features)
-------------------------------------------------

Ce sont des motifs rectangulaires simples qui mesurent les diffÃ©rences
d'intensitÃ© lumineuse entre zones adjacentes.

Exemples de motifs :
--------------------

â”Œâ”€â”€â”€â”€â”¬â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”¬â”€â”€â”€â”€â”
â”‚    â”‚â–ˆâ–ˆâ–ˆâ–ˆâ”‚     â”‚         â”‚     â”‚â–ˆâ–ˆâ–ˆâ–ˆâ”‚    â”‚
â”‚    â”‚â–ˆâ–ˆâ–ˆâ–ˆâ”‚     â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚     â”‚â–ˆâ–ˆâ–ˆâ–ˆâ”‚    â”‚
â””â”€â”€â”€â”€â”´â”€â”€â”€â”€â”˜     â”‚â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ”‚     â””â”€â”€â”€â”€â”´â”€â”€â”€â”€â”˜
  Edge           â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       Edge
 (vertical)         Line          (horizontal)

â”Œâ”€â”€â”€â”€â”¬â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”
â”‚    â”‚â–ˆâ–ˆâ–ˆâ–ˆâ”‚     â”‚    â”‚â–ˆâ–ˆâ–ˆâ–ˆâ”‚    â”‚
â”œâ”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¤     â”‚    â”‚â–ˆâ–ˆâ–ˆâ–ˆâ”‚    â”‚
â”‚â–ˆâ–ˆâ–ˆâ–ˆâ”‚    â”‚     â””â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”˜
â””â”€â”€â”€â”€â”´â”€â”€â”€â”€â”˜        Four rect

Calcul :
--------
Valeur = Somme(pixels blancs) - Somme(pixels noirs)

2. Image intÃ©grale (Integral Image)
------------------------------------

Technique d'optimisation pour calculer rapidement la somme de pixels
dans n'importe quel rectangle.

Calcul en 4 opÃ©rations au lieu de parcourir tous les pixels !

3. Cascade de classifieurs
---------------------------

SÃ©rie de tests hiÃ©rarchiques (cascade) :
â€¢ Ã‰tape 1 : Tests simples, rapides â†’ Rejette 90% des zones
â€¢ Ã‰tape 2 : Tests plus complexes â†’ Rejette 90% du reste
â€¢ ...
â€¢ Ã‰tape N : Tests finaux prÃ©cis â†’ Valide dÃ©tection

Si une zone Ã©choue Ã  une Ã©tape, elle est immÃ©diatement rejetÃ©e.
â†’ Performance : seules les zones prometteuses passent tous les tests.

4. EntraÃ®nement (AdaBoost)
---------------------------

Le modÃ¨le a Ã©tÃ© entraÃ®nÃ© sur :
â€¢ Milliers d'images positives (contenant des visages)
â€¢ Milliers d'images nÃ©gatives (sans visages)

RÃ©sultat : Fichier XML contenant les caractÃ©ristiques apprises.

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ AVANTAGES ET LIMITATIONS                                                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Avantages :
-----------
âœ“ TrÃ¨s rapide (temps rÃ©el)
âœ“ LÃ©ger (pas de deep learning)
âœ“ Fonctionne sur CPU
âœ“ PrÃ©-entraÃ®nÃ© (pas besoin de donnÃ©es)

Limitations :
-------------
âœ— Sensible Ã  l'angle de vue (frontal uniquement)
âœ— Sensible Ã  l'Ã©clairage
âœ— Moins prÃ©cis que les rÃ©seaux de neurones modernes
âœ— Faux positifs possibles
âœ— Ne reconnaÃ®t pas l'identitÃ© (juste dÃ©tecte prÃ©sence)

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
15.5 EXEMPLE COMPLET : DÃ‰TECTION VISAGES TEMPS RÃ‰EL
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import cv2

# 1. Charger le dÃ©tecteur
cascade_path = cv2.data.haarcascades + "haarcascade_frontalface_default.xml"
detector = cv2.CascadeClassifier(cascade_path)

# 2. Ouvrir la webcam
cap = cv2.VideoCapture(0)

while True:
    # 3. Lire une frame
    ret, frame = cap.read()
    if not ret:
        break
    
    # 4. Convertir en niveau de gris
    gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
    
    # 5. DÃ©tecter les visages
    faces = detector.detectMultiScale(gray, scaleFactor=1.1, minNeighbors=5)
    
    # 6. Dessiner rectangles sur chaque visage
    for (x, y, w, h) in faces:
        cv2.rectangle(frame, (x, y), (x+w, y+h), (0, 255, 0), 2)
        cv2.putText(
            frame, 
            "Visage", 
            (x, y-10), 
            cv2.FONT_HERSHEY_SIMPLEX, 
            0.6, 
            (0, 255, 0), 
            2
        )
    
    # 7. Afficher le rÃ©sultat
    cv2.imshow("Detection", frame)
    
    # 8. Quitter avec 'q'
    if cv2.waitKey(1) & 0xFF == ord('q'):
        break

# 9. LibÃ©rer ressources
cap.release()
cv2.destroyAllWindows()

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
15.6 INTÃ‰GRATION OPENCV + TKINTER
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ProblÃ¨me : OpenCV affiche avec cv2.imshow() (fenÃªtres natives)
             Tkinter a son propre systÃ¨me de fenÃªtres

Solution : Convertir frames OpenCV â†’ ImageTk pour affichage Tkinter

Ã‰tapes :
--------
1. Capturer frame OpenCV (BGR)
2. Convertir BGR â†’ RGB
3. Redimensionner si nÃ©cessaire
4. Convertir numpy array â†’ PIL Image
5. Convertir PIL Image â†’ ImageTk.PhotoImage
6. Afficher dans Label Tkinter

Code exemple :
--------------
import cv2
from PIL import Image, ImageTk
import tkinter as tk

def update_frame():
    ret, frame = cap.read()
    if ret:
        # Convertir BGR â†’ RGB
        frame_rgb = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
        
        # Redimensionner
        frame_resized = cv2.resize(frame_rgb, (640, 480))
        
        # Convertir â†’ PIL â†’ ImageTk
        img = Image.fromarray(frame_resized)
        photo = ImageTk.PhotoImage(image=img)
        
        # Afficher dans Label
        label.config(image=photo)
        label.image = photo  # Garde rÃ©fÃ©rence (important !)
    
    # Rappeler aprÃ¨s 50ms (20 FPS)
    root.after(50, update_frame)

root = tk.Tk()
label = tk.Label(root)
label.pack()

cap = cv2.VideoCapture(0)
update_frame()

root.mainloop()
cap.release()

IMPORTANT : label.image = photo
----------------------------
Sans cette ligne, Python garbage collector dÃ©truit l'image immÃ©diatement
et le Label affiche du noir !

================================================================================
                          16. GLOSSAIRE
================================================================================

BGR : Blue-Green-Red, format couleur OpenCV (inverse du RGB)
Cooldown : DÃ©lai minimum entre deux actions identiques
Dataclass : DÃ©corateur Python gÃ©nÃ©rant automatiquement __init__, etc.
Encoding : ReprÃ©sentation numÃ©rique d'un visage (vecteur)
FPS : Frames Per Second (images par seconde)
Haar Cascade : Algorithme de dÃ©tection d'objets basÃ© sur des motifs
ImageTk : Module Tkinter pour afficher images PIL/numpy
JSON : JavaScript Object Notation, format d'Ã©change de donnÃ©es
OpenCV : Open Computer Vision, bibliothÃ¨que de vision par ordinateur
ROI : Region Of Interest (rÃ©gion d'intÃ©rÃªt dans une image)
Tkinter : BibliothÃ¨que graphique standard Python
TolÃ©rance : Seuil de distance pour considÃ©rer deux visages comme identiques

================================================================================
                    17. FONCTIONNALITÃ‰S IMPLÃ‰MENTÃ‰ES
================================================================================

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
Ã‰TAT FONCTIONNEL DU PROJET
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ âœ… FONCTIONNALITÃ‰S PRINCIPALES IMPLÃ‰MENTÃ‰ES ET TESTÃ‰ES                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

[âœ…] Authentification administrateur
     - Connexion avec username/password
     - VÃ©rification via data/admins.json
     - Redirection vers menu principal si succÃ¨s
     - Message d'erreur si Ã©chec
     - Statut : FONCTIONNEL âœ“

[âœ…] Ajout d'Ã©tudiants
     - Formulaire complet (ID, nom, prÃ©nom, solde)
     - Validation des champs obligatoires
     - Capture photo via webcam (mode continu avec touche C)
     - Import de photo depuis fichier
     - PrÃ©visualisation avant enregistrement
     - Sauvegarde automatique dans data/students.json
     - Statut : FONCTIONNEL âœ“

[âœ…] Encodage facial
     - DÃ©tection automatique des visages (Haar Cascade)
     - Extraction de la rÃ©gion du visage
     - Redimensionnement standardisÃ© (100x100 pixels)
     - Normalisation des valeurs [0,1]
     - GÃ©nÃ©ration du vecteur d'encodage (10,000 floats)
     - Statut : FONCTIONNEL âœ“

[âœ…] Reconnaissance faciale en temps rÃ©el
     - Flux vidÃ©o continu (20 FPS)
     - DÃ©tection multi-visages par frame
     - Comparaison avec base d'Ã©tudiants
     - Overlay visuel (rectangles + noms)
     - Rectangle VERT pour visages reconnus
     - Rectangle ROUGE pour visages inconnus
     - Affichage du nom et du solde
     - Statut : FONCTIONNEL âœ“

[âœ…] Gestion automatique du solde
     - DÃ©bit automatique lors de la reconnaissance (1.0â‚¬ par passage)
     - Cooldown anti-doublon (3 secondes)
     - Le solde ne descend jamais en dessous de 0â‚¬
     - Affichage du solde restant en temps rÃ©el
     - Message d'alerte si solde insuffisant
     - Persistance dans students.json
     - Statut : FONCTIONNEL âœ“

[âœ…] Interface utilisateur (Tkinter)
     - FenÃªtre principale 1200x800
     - Navigation fluide entre les Ã©crans
     - Ã‰cran de connexion
     - Menu principal avec 3 options
     - Formulaire d'ajout d'Ã©tudiant
     - Vue de contrÃ´le d'accÃ¨s avec vidÃ©o
     - Messages de confirmation/erreur (messagebox)
     - Design moderne avec ttk
     - Statut : FONCTIONNEL âœ“

[âœ…] Persistance des donnÃ©es
     - Sauvegarde automatique en JSON
     - Chargement au dÃ©marrage
     - Format structurÃ© et lisible
     - Encodage UTF-8 (gÃ¨re accents)
     - data/students.json pour les Ã©tudiants
     - data/admins.json pour les administrateurs
     - data/images/ pour les photos
     - Statut : FONCTIONNEL âœ“

[âœ…] Gestion de la camÃ©ra
     - Ouverture/fermeture automatique
     - Optimisation : camÃ©ra reste ouverte pendant utilisation
     - Capture ponctuelle pour ajout Ã©tudiant
     - Flux continu pour reconnaissance
     - Fermeture propre avec teardown()
     - Gestion d'erreur si camÃ©ra indisponible
     - Statut : FONCTIONNEL âœ“

[âœ…] Logs et feedback utilisateur
     - Affichage du statut en temps rÃ©el
     - Timestamp du dernier passage
     - Messages de confirmation aprÃ¨s actions
     - Indicateurs visuels (couleurs, symboles)
     - Statut : FONCTIONNEL âœ“

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ âš ï¸ FONCTIONNALITÃ‰S PARTIELLES OU LIMITATIONS                                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

[âš ï¸] SÃ©curitÃ© des mots de passe
     - Mots de passe stockÃ©s en clair dans admins.json
     - Pas de hash bcrypt
     - AmÃ©lioration recommandÃ©e : Utiliser bcrypt pour hasher les mots de passe
     - Statut : FONCTIONNEL MAIS NON SÃ‰CURISÃ‰

[âš ï¸] PrÃ©cision de la reconnaissance
     - Algorithme simplifiÃ© (100x100 pixels)
     - TolÃ©rance permissive (15.0)
     - Sensible Ã  l'Ã©clairage et Ã  l'angle
     - Peut gÃ©nÃ©rer des faux positifs
     - AmÃ©lioration recommandÃ©e : Utiliser face_recognition (dlib) pour plus de prÃ©cision
     - Statut : FONCTIONNEL MAIS PERFECTIBLE

[âš ï¸] ScalabilitÃ©
     - JSON non optimisÃ© pour grandes bases de donnÃ©es
     - Peut ralentir avec >1000 Ã©tudiants
     - Chargement complet en mÃ©moire Ã  chaque opÃ©ration
     - AmÃ©lioration recommandÃ©e : Migrer vers SQLite
     - Statut : ADAPTÃ‰ AU CONTEXTE SCOLAIRE

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ âŒ FONCTIONNALITÃ‰S NON IMPLÃ‰MENTÃ‰ES (HORS SCOPE)                            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

[âŒ] Logs d'audit persistants
     - Pas d'historique des passages sauvegardÃ©
     - AmÃ©lioration future : Table SQLite ou CSV avec timestamp/Ã©tudiant/solde

[âŒ] Interface d'administration avancÃ©e
     - Pas de modification/suppression d'Ã©tudiants via l'interface
     - Pas de statistiques/rapports
     - AmÃ©lioration future : CRUD complet dans l'interface

[âŒ] Multi-camÃ©ras
     - Support d'une seule camÃ©ra
     - AmÃ©lioration future : Configuration pour plusieurs points d'accÃ¨s

[âŒ] Notifications
     - Pas d'email/SMS si solde bas
     - AmÃ©lioration future : SystÃ¨me d'alertes

[âŒ] Export de donnÃ©es
     - Pas d'export CSV/PDF pour comptabilitÃ©
     - AmÃ©lioration future : Bouton d'export dans le menu

[âŒ] Base de donnÃ©es relationnelle
     - Pas de SQLite/MySQL
     - JSON suffisant pour le projet pÃ©dagogique

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
RÃ‰SUMÃ‰ DES TESTS EFFECTUÃ‰S
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

âœ“ Test 1 : Authentification
   - Login correct â†’ AccÃ¨s autorisÃ© âœ…
   - Login incorrect â†’ Message d'erreur âœ…

âœ“ Test 2 : Ajout d'Ã©tudiant
   - Formulaire complet + photo â†’ Enregistrement rÃ©ussi âœ…
   - Formulaire incomplet â†’ Message d'avertissement âœ…
   - VÃ©rification dans students.json â†’ DonnÃ©es prÃ©sentes âœ…

âœ“ Test 3 : Reconnaissance valide
   - Ã‰tudiant enregistrÃ© devant camÃ©ra â†’ Rectangle vert + nom âœ…
   - DÃ©bit du solde â†’ Montant mis Ã  jour âœ…
   - Affichage du solde restant â†’ Correct âœ…

âœ“ Test 4 : Reconnaissance invalide
   - Personne inconnue devant camÃ©ra â†’ Rectangle rouge + "INCONNU" âœ…
   - Message "AccÃ¨s refusÃ©" â†’ AffichÃ© âœ…
   - Pas de dÃ©bit â†’ ConfirmÃ© âœ…

âœ“ Test 5 : Cooldown anti-doublon
   - MÃªme Ã©tudiant reste 10 secondes â†’ DÃ©bitÃ© seulement 3 fois âœ…
   - Intervalle de 3 secondes respectÃ© â†’ ConfirmÃ© âœ…

âœ“ Test 6 : Solde insuffisant
   - Ã‰tudiant avec solde 0â‚¬ â†’ Message "Solde insuffisant" âœ…
   - Reconnaissance fonctionne â†’ Oui, mais pas de dÃ©bit âœ…

âœ“ Test 7 : Flux vidÃ©o
   - FluiditÃ© 20 FPS â†’ ConfirmÃ© âœ…
   - DÃ©tection multi-visages â†’ 2 visages dÃ©tectÃ©s simultanÃ©ment âœ…
   - Fermeture propre de la camÃ©ra â†’ LED s'Ã©teint âœ…

âœ“ Test 8 : Navigation
   - Tous les boutons fonctionnent â†’ âœ…
   - Retour au menu â†’ âœ…
   - DÃ©connexion â†’ Retour Ã  l'Ã©cran de login âœ…

================================================================================
                         18. BILAN PERSONNEL DU PROJET
================================================================================

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
CONTEXTE ET OBJECTIFS
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Ce projet a Ã©tÃ© rÃ©alisÃ© dans le cadre du mini-projet Python DSN Ã  l'Institut
Limayrac. L'objectif Ã©tait de crÃ©er une application de contrÃ´le d'accÃ¨s au
restaurant scolaire basÃ©e sur la reconnaissance faciale.

DurÃ©e du projet : Environ 3-4 semaines
Environnement : Python 3.11, Tkinter, OpenCV

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
DIFFICULTÃ‰S RENCONTRÃ‰ES ET SOLUTIONS APPORTÃ‰ES
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ DIFFICULTÃ‰ 1 : Choix de la bibliothÃ¨que de reconnaissance faciale          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

ProblÃ¨me :
----------
Au dÃ©part, j'ai tentÃ© d'utiliser la bibliothÃ¨que face_recognition (basÃ©e sur
dlib), mais j'ai rencontrÃ© des problÃ¨mes d'installation :
- dlib nÃ©cessite CMake et Visual C++ Build Tools
- Compilation longue et complexe sur Windows
- Erreurs de compilation rÃ©currentes

Solution adoptÃ©e :
------------------
J'ai optÃ© pour une approche avec OpenCV uniquement :
- DÃ©tection avec Haar Cascade (intÃ©grÃ© Ã  OpenCV)
- Encodage simplifiÃ© (100x100 pixels normalisÃ©s)
- Distance euclidienne pour la comparaison

RÃ©sultat :
----------
âœ“ Installation beaucoup plus simple (pip install opencv-python)
âœ“ Pas de dÃ©pendances lourdes
âœ“ Performance suffisante pour le projet
âœ— Moins prÃ©cis que face_recognition, mais acceptable

Apprentissage :
---------------
Il vaut parfois mieux une solution simple et fonctionnelle qu'une solution
complexe et thÃ©oriquement meilleure mais impossible Ã  faire fonctionner.

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ DIFFICULTÃ‰ 2 : IntÃ©gration OpenCV et Tkinter                                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

ProblÃ¨me :
----------
OpenCV utilise ses propres fenÃªtres (cv2.imshow) incompatibles avec Tkinter.
Le flux vidÃ©o devait s'afficher dans l'interface Tkinter.

Solution adoptÃ©e :
------------------
Conversion des frames OpenCV en ImageTk.PhotoImage :
1. Lecture frame OpenCV (BGR)
2. Conversion BGR â†’ RGB (cv2.cvtColor)
3. Redimensionnement avec cv2.resize
4. Conversion numpy array â†’ PIL Image
5. Conversion PIL â†’ ImageTk.PhotoImage
6. Affichage dans Label Tkinter
7. Boucle avec self.after(50ms)

PiÃ¨ge Ã©vitÃ© :
-------------
Sans garder une rÃ©fÃ©rence Ã  l'image (self._preview_image = photo), Python
garbage collector la dÃ©truit immÃ©diatement et le Label affiche du noir.

RÃ©sultat :
----------
âœ“ Flux vidÃ©o fluide Ã  20 FPS dans Tkinter
âœ“ Overlay graphique (rectangles + texte) fonctionnel

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ DIFFICULTÃ‰ 3 : Gestion du cooldown anti-doublon                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

ProblÃ¨me :
----------
Au dÃ©but, sans cooldown, un Ã©tudiant Ã©tait dÃ©bitÃ© 20 fois par seconde (20 FPS).
Un passage de 3 secondes devant la camÃ©ra = 60â‚¬ dÃ©bitÃ©s !

Solution adoptÃ©e :
------------------
ImplÃ©mentation d'un systÃ¨me de cooldown :
- Variable _last_detection_time stocke le timestamp du dernier dÃ©bit
- Avant de dÃ©biter, vÃ©rification : current_time - _last_detection_time > 3s
- Si cooldown actif, on reconnaÃ®t mais ne dÃ©bite pas

RÃ©sultat :
----------
âœ“ Un seul dÃ©bit toutes les 3 secondes maximum
âœ“ Reconnaissance continue pour feedback visuel
âœ“ Pas de doublons

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ DIFFICULTÃ‰ 4 : Performance de la reconnaissance                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

ProblÃ¨me :
----------
Au dÃ©but, la reconnaissance Ã©tait lente (< 5 FPS) car :
- Chargement de students.json Ã  chaque frame
- Calcul de distance avec TOUS les Ã©tudiants Ã  chaque frame
- CamÃ©ra s'ouvrait/fermait Ã  chaque capture (2-5 secondes de dÃ©lai)

Solution adoptÃ©e :
------------------
Optimisations multiples :
1. CamÃ©ra reste ouverte pendant toute la session (modification rÃ©cente)
2. PrÃ©-chargement des Ã©tudiants au dÃ©marrage de la vue
3. DÃ©tection/encodage optimisÃ©s avec Haar Cascade
4. Break dÃ¨s qu'un match est trouvÃ© (pas besoin de tout parcourir)

RÃ©sultat :
----------
âœ“ Flux Ã  20 FPS stable
âœ“ Reconnaissance instantanÃ©e
âœ“ Latence < 50ms

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ DIFFICULTÃ‰ 5 : Architecture et organisation du code                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

ProblÃ¨me :
----------
Au dÃ©but, tout Ã©tait dans un seul fichier de 500+ lignes, difficile Ã  maintenir.

Solution adoptÃ©e :
------------------
Refactorisation en architecture MVC :
- models/ : ModÃ¨les de donnÃ©es (Student)
- services/ : Logique mÃ©tier (auth, camera, storage, reconnaissance)
- ui/ : Interfaces Tkinter (vues)
- utils/ : Constantes et utilitaires

Pattern Dependency Injection :
Les services sont crÃ©Ã©s dans app.py et injectÃ©s dans les vues.

RÃ©sultat :
----------
âœ“ Code modulaire et maintenable
âœ“ SÃ©paration des responsabilitÃ©s
âœ“ Facilite les tests et les modifications
âœ“ RÃ©utilisabilitÃ© des services

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
COMPÃ‰TENCES ACQUISES
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ”¹ Vision par ordinateur
   - ComprÃ©hension de Haar Cascade
   - DÃ©tection d'objets en temps rÃ©el
   - Encodage et comparaison d'images
   - Manipulation d'images avec NumPy

ğŸ”¹ DÃ©veloppement d'interfaces graphiques
   - Tkinter et ttk
   - IntÃ©gration de flux vidÃ©o dans GUI
   - Gestion d'Ã©vÃ©nements et callbacks
   - Navigation multi-Ã©crans

ğŸ”¹ Architecture logicielle
   - Pattern MVC
   - Dependency Injection
   - SÃ©paration des responsabilitÃ©s
   - Code modulaire et rÃ©utilisable

ğŸ”¹ Gestion de donnÃ©es
   - Persistance JSON
   - SÃ©rialisation/dÃ©sÃ©rialisation
   - CRUD sur fichiers
   - Encodage UTF-8

ğŸ”¹ Optimisation
   - Profiling de performance
   - Optimisation de boucles
   - Gestion de mÃ©moire (garbage collector)
   - Flux vidÃ©o temps rÃ©el

ğŸ”¹ DÃ©bogage
   - RÃ©solution de problÃ¨mes d'intÃ©gration
   - Lecture de documentation technique
   - Tests manuels systÃ©matiques

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
POINTS FORTS DU PROJET
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

âœ“ FonctionnalitÃ©s demandÃ©es toutes implÃ©mentÃ©es
âœ“ Architecture propre et modulaire
âœ“ Documentation technique exhaustive (2100+ lignes)
âœ“ Code commentÃ© et lisible
âœ“ Interface utilisateur intuitive
âœ“ Performance temps rÃ©el (20 FPS)
âœ“ Gestion d'erreurs robuste
âœ“ Cooldown anti-doublon efficace
âœ“ Pas de dÃ©pendances complexes (installation simple)

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
POINTS D'AMÃ‰LIORATION IDENTIFIÃ‰S
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

1. PrÃ©cision de la reconnaissance
   - Remplacer l'encodage simplifiÃ© par face_recognition (dlib)
   - EntraÃ®ner avec plusieurs photos par Ã©tudiant
   - Ajuster dynamiquement la tolÃ©rance selon les conditions

2. SÃ©curitÃ©
   - Hasher les mots de passe avec bcrypt
   - Chiffrer les donnÃ©es sensibles
   - Ajouter des logs d'audit sÃ©curisÃ©s

3. Base de donnÃ©es
   - Migrer de JSON vers SQLite
   - Optimiser les requÃªtes avec index
   - Support de transactions

4. FonctionnalitÃ©s additionnelles
   - CRUD complet dans l'interface (modifier/supprimer Ã©tudiants)
   - Export CSV/PDF pour comptabilitÃ©
   - Statistiques de frÃ©quentation
   - Notifications par email si solde bas

5. Tests automatisÃ©s
   - Tests unitaires avec pytest
   - Tests d'intÃ©gration
   - Couverture de code > 80%

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
UTILISATION DE L'IA
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

L'IA (Cursor AI avec Claude) a Ã©tÃ© utilisÃ©e pour :

âœ“ GÃ©nÃ©ration de donnÃ©es de test rÃ©alistes
   - CrÃ©ation de 10,000+ Ã©tudiants fictifs avec noms/prÃ©noms franÃ§ais
   - GÃ©nÃ©ration de soldes rÃ©alistes (entre 0â‚¬ et 20â‚¬)

âœ“ Aide au dÃ©bogage
   - Identification de problÃ¨mes de performance
   - Suggestions d'optimisation (camÃ©ra persistante)
   - RÃ©solution d'erreurs d'intÃ©gration OpenCV/Tkinter

âœ“ Documentation
   - Structuration de la documentation technique
   - GÃ©nÃ©ration d'exemples de code
   - Explication des concepts (Haar Cascade, distance euclidienne)

âœ“ Refactorisation
   - Suggestions d'architecture MVC
   - Identification de code dupliquÃ©
   - Propositions d'amÃ©lioration

Code Ã©crit personnellement vs IA :
-----------------------------------
- Architecture globale : 100% personnel
- Logique mÃ©tier : 80% personnel, 20% suggestions IA
- Interface Tkinter : 90% personnel
- Documentation : 60% personnel, 40% aide IA
- Tests et dÃ©bogage : 100% personnel

L'IA a Ã©tÃ© un outil d'aide et d'accÃ©lÃ©ration, mais la comprÃ©hension, les
dÃ©cisions d'architecture et l'implÃ©mentation finale restent personnelles.

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
CONCLUSION
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Ce projet m'a permis de mettre en pratique de nombreux concepts Python :
- POO avec dataclasses
- Architecture logicielle (MVC, DI)
- Vision par ordinateur avec OpenCV
- Interfaces graphiques avec Tkinter
- Gestion de donnÃ©es avec JSON

Les difficultÃ©s rencontrÃ©es (intÃ©gration OpenCV/Tkinter, performance, cooldown)
ont Ã©tÃ© des opportunitÃ©s d'apprentissage prÃ©cieuses.

Le rÃ©sultat final est une application fonctionnelle, performante et
maintenable qui rÃ©pond Ã  tous les objectifs du cahier des charges.

Si c'Ã©tait Ã  refaire :
-----------------------
- Je commencerais par SQLite dÃ¨s le dÃ©but
- J'ajouterais des tests unitaires au fur et Ã  mesure
- Je ferais plus de profiling de performance en amont
- J'utiliserais face_recognition malgrÃ© la complexitÃ© d'installation

Temps estimÃ© :
--------------
- Architecture et setup : 4h
- DÃ©veloppement interface Tkinter : 8h
- IntÃ©gration OpenCV et reconnaissance : 12h
- Optimisation et dÃ©bogage : 6h
- Documentation : 10h
- Tests et vidÃ©o : 4h
TOTAL : ~44 heures

Satisfaction :
--------------
9/10 - TrÃ¨s satisfait du rÃ©sultat. Le projet fonctionne bien et la
documentation est complÃ¨te. La seule frustration est la prÃ©cision de la
reconnaissance qui pourrait Ãªtre meilleure avec face_recognition.

================================================================================
                          FIN DE LA DOCUMENTATION
================================================================================

Pour toute question ou amÃ©lioration, consulter :
- README.md
- Code source commentÃ©
- Documentation officielle OpenCV : https://docs.opencv.org
- Documentation Tkinter : https://docs.python.org/3/library/tkinter.html

